今天来盘一盘 **栈以及队列 ** 这两类题目



使用**python**刷题分类整理的笔记,请参考:  [https://github.com/lxztju/leetcode-algorithm/tree/v1](https://github.com/lxztju/leetcode-algorithm/tree/v1)

## 栈和队列

> **栈: 先进先出 
> 队列: 先进后出**

利用这两类数据结构的特性解题.

其中一类非常经典的题目是: **单调栈(leetcode496题, 经典题目)**. 

* **单调递减栈**, 是指针对每一个待遍历的元素x, 将x与栈顶元素相比, 如果大于栈顶元素将栈顶元素出栈, 重新循环对比,直到小于栈顶元素,然后将x入栈. 
* **单调递增栈**: 同理分析

---

* 232 用栈实现队列 (Easy)


####  232 用栈实现队列 (Easy)
*python定义类
*使用两个栈实现这一操作
*push为入队列操作
*pop为出队列操作，在这个操作中进行汉诺塔操作
*peek返回队列头顶元素
```python
class MyQueue(object):

    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.stack1=[]
        self.stack2 = []


    def push(self, x):
        """
        Push element x to the back of queue.
        :type x: int
        :rtype: None
        """
        """
        while self.stack1:
            self.stack2.append(self.stack1.pop())
        """
        self.stack1.append(x)  
        """
        while self.stack2:
            self.stack1.append(self.stack2.pop())
        """      

    def pop(self):
        """
        Removes the element from in front of queue and returns that element.
        :rtype: int
        """
        while self.stack1:
            self.stack2.append(self.stack1.pop())
        a = self.stack2.pop()
        while self.stack2:
            self.stack1.append(self.stack2.pop())
        return a

    def peek(self):
        """
        Get the front element.
        :rtype: int
        """   
        return self.stack1[0]
     


    def empty(self):
        """
        Returns whether the queue is empty.
        :rtype: bool
        """
        return not self.stack1
```
